#
# 什么是TypeScript

> Typed JavaScript at Any Scale
> 添加了类型系统的JavaScript，适用于任何规模的项目

TypeScript两个最重要的特性————类型系统、适用于任何规模

### TypeScript的特性

##### 类型系统

从名字就可以看出，「类型」是其最核心的特性。

我们知道，JavaScript 是一门非常灵活的编程语言：

- 它没有类型约束，一个变量可能初始化时是字符串，过一会儿又被赋值为数字。
- 由于隐式类型转换的存在，有的变量的类型很难在运行前就确定。
- 基于原型的面向对象编程，使得原型上的属性或方法可以在运行时被修改。
- 函数是 JavaScript 中的一等公民[2]，可以赋值给变量，也可以当作参数或返回值。
- 这种灵活性就像一把双刃剑，一方面使得 JavaScript 蓬勃发展，无所不能，从 2013 年开始就一直蝉联最普遍使用的编程语言排行榜冠军[3]；另一方面也使得它的代码质量参次不起，维护成本高，运行时错误多。

而 TypeScript 的类型系统，在很大程度上弥补了 JavaScript 的缺点。

##### TypeScript是静态类型

类型系统按照「类型检查的时机」来分类，可以分为动态类型和静态类型。

动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行的错误。

JavaScript是一门解释型语言，没有编译阶段，所以它是动态类型，以下代码在运行时会报错：

```js
let foo = 1;
foo.split(' ');
// Uncaught TypeError: foo.split is not a function
// 运行时会报错（foo.split 不是一个函数），造成线上 bug
```

静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。

TypeScript在运行前需要先编译为JavaScript，而在编译阶段就会进行类型检查，所以**TypeScript是静态类型**，
这段TypeScript代码在编译阶段就会报错了：

```js
let foo = 1;
foo.split(' ');
// Property 'split' does not exist on type 'number'.
// 编译时会报错（数字没有 split 方法），无法通过编译
```
你可能会奇怪，这段 TypeScript 代码看上去和 JavaScript 没有什么区别呀。

没错！大部分 JavaScript 代码都只需要经过少量的修改（或者完全不用修改）就变成 TypeScript 代码
，这得益于 TypeScript 强大的[类型推论][]，即使不去手动声明变量 foo 的类型，
也能在变量初始化时自动推论出它是一个 number 类型。

完整的TypeScript代码是这样的：

```js
let foo: number = 1;
foo.split(' ');
// Property 'split' does not exist on type 'number'.
// 编译时会报错（数字没有 split 方法），无法通过编译
```
##### TypeScript是弱类型

类型系统按照「是否允许隐式类型转化」来分类，可以分为强类型和弱类型。

以下这段代码不管是在 JavaScript 中还是在 TypeScript 中都是可以正常运行的，
运行时数字 1 会被隐式类型转换为字符串 '1'，加号 + 被识别为字符串拼接，
所以打印出结果是字符串 '11'。

```js
console.log(1 + '1');
// 打印出字符串 '11'
```
TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性，所以
**它们都是弱类型**。

作为对比，Python 是强类型，以下代码会在运行时报错：

```js
print(1 + '1')
# TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

若要修复该错误，需要进行强制类型转换：

```js
print(str(1) + '1')
# 打印出字符串 '11'
```

这样的类型系统提现了TypeScript的核心设计理念：在完整保留JavaScript运行时行为的基础上，
通过引入静态类型系统来提高代码的可维护性，减少可能出现的bug。

##### 总结

什么是TypeScript?

- TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。
- TypeScript 是一门静态类型、弱类型的语言。
- TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。
- TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。
- TypeScript 拥有很多编译选项，类型检查的严格程度由你决定。
- TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。
- TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。
- TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明。
- TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3）。

##### TypeScript的发展历史

- 2012-10：微软发布了 TypeScript 第一个版本（0.8），此前已经在微软内部开发了两年。
- 2014-04：TypeScript 发布了 1.0 版本。
- 2014-10：Angular 发布了 2.0 版本，它是一个基于 TypeScript 开发的前端框架。
- 2015-01：ts-loader 发布，webpack 可以编译 TypeScript 文件了。
- 2015-04：微软发布了 Visual Studio Code，它内置了对 TypeScript 语言的支持，它自身也是用 TypeScript 开发的。
- 2016-05：@types/react 发布，TypeScript 可以开发 React 应用了。
- 2016-05：@types/node 发布，TypeScript 可以开发 Node.js 应用了。
- 2016-09：TypeScript 发布了 2.0 版本。
- 2018-06：TypeScript 发布了 3.0 版本。
- 2019-02：TypeScript 宣布由官方团队来维护 typescript-eslint，以支持在 TypeScript 文件中运行 ESLint 检查。
- 2020-05：Deno 发布了 1.0 版本，它是一个 JavaScript 和 TypeScript 运行时。
- 2020-08：TypeScript 发布了 4.0 版本。
- 2020-09：Vue 发布了 3.0 版本，官方支持 TypeScript。

# 安装TypeScript

命令行工具安装方法如下：

```js
npm install -g typescript
```

我们约定使用 TypeScript 编写的文件以 `.ts` 为后缀，
用 TypeScript 编写 React 时，以 `.tsx` 为后缀。

# Hello TypeScript

将以下代码复制到`hello.ts`中：

```js
function sayHello(person: string) {
    return 'Hello, ' + person;
}

let user = 'Tom';
console.log(sayHello(user));
```

然后执行

```js
tsc hello.ts
```

这时候会生成一个编译好的文件`hello.js`：

```js
function sayHello(person) {
    return 'Hello, ' + person;
}
var user = 'Tom';
console.log(sayHello(user));
```
在TypeScript中，我们使用`:`指定变量的类型，`:`的前后有没有空格都可以。

上述例子中，我们用 `:` 指定 person 参数类型为 string。
但是编译为 js 之后，并没有什么检查的代码被插入进来。

这是因为 TypeScript 只会在编译时对类型进行静态检查，如果发现有错误，
编译的时候就会报错。而在运行时，与普通的 JavaScript 文件一样，
不会对类型进行检查。

如果我们需要保证运行时的参数类型，还是得手动对类型进行判断：

```js
function sayHello(person: string) {
    if (typeof person === 'string') {
        return 'Hello, ' + person;
    } else {
        throw new Error('person is not a string');
    }
}

let user = 'Tom';
console.log(sayHello(user));
```